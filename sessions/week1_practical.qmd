---
title: 'Practical 1: describing and representing data'
subtitle: "Starting with the 'Basics'"
format:
  html: default
  ipynb: default
filters:
  - qna
  - quarto
---

This week is focussed on ensuring that you're able to access the teaching materials and to run Jupyter notebooks locally, as well as describing a dataset in Python.

## Learning Outcomes

-   You have familiarised yourself with how to access the lecture notes and Python notebook of this module.
-   You have familiarised yourself with running the Python notebooks locally.
-   You have familiarised yourself with describing a dataset in Python.

# Starting the Practical

The process for every week will be the same: download the notebook to your `QM` folder, switch over to `JupyterLab` (which will be running in Podman/Docker) and get to work. If you want to save the completed notebook to your Github repo, you can `add`, `commit`, and `push` the notebook in Git after you download it. When you're done for the day, save your changes to the file (This is very important!), then `add`, `commit`, and `push` your work to save the completed notebook.

:::{.callout-note}

Suggestions for a Better Learning Experience:

-   **Set your operating system and software language to English**: this will make it easier to follow tutorials, search for solutions online, and understand error messages.

-   **Save all files to a cloud storage service**: use platforms like Google Drive, OneDrive, Dropbox, or Git to ensure your work is backed up and can be restored easily when the laptop gets stolen or broken.

-   **Avoid whitespace in file names and column names in datasets**
:::

## Set up the tools

Please follow [the Setup page of CASA0013](https://jreades.github.io/fsds/setup/) to install and configure the computing platform, and [this page](https://jreades.github.io/fsds/sessions/week1.html) to get started on using the container & JupyterLab.

## Download the Notebook

So for this week, visit the [Week 1 of QM page](https://huanfachen.github.io/QM/sessions/week1.html#practical), you'll see that there is a 'preview' link and a a 'download' link. If you click the `preview` link you will be taken to the GitHub page for the notebook where it has been 'rendered' as a web page, which is not editable. To make the notebook useable on *your* computer, you need to `download` the IPYNB file.

So now:

1.  Click on the `Download` link.
2.  The file should download automatically, but *if* you see a page of raw code, select `File` then `Save Page As...`.
3.  Make sure you know where to find the file (e.g. Downloads or Desktop).
4.  Move the file to your Git repository folder (e.g. `~/Documents/CASA/QM/`)
5.  Check to see if your browser has added `.txt` to the file name:
    -   If no, then you can move to adding the file.
    -   If yes, then you can either fix the name in the Finder/Windows Explore, or you can do this in the Terminal using `mv <name_of_practical>.ipynb.txt <name_of_practical>.ipynb` (you can even do this in JupyterLab's terminal if it's already running).

## Running notebooks on JupyterLab

I am assuming that most of you are already running JupyterLab via Podman using the command.

If you are a bit confused with *container*, *JupyterLab*, *terminal*, or *Git*, please feel free to ask any questions.

## Loading data

We are going to describe the population of local authorities in the UK. 

The data is sourced from [Office for National Statistics](https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/articles/howyourareahaschangedin10yearscensus2021/2022-11-08) and is donwloadable [here](https://www.ons.gov.uk/visualisations/censusareachanges/data/mapdatadownload.csv). 

We have saved a copy of this dataset to the Github repo, in case that the dataset is removed from the website.

```{python}
import pandas as pd

# Read CSV file, skipping first 5 rows, using row 6 as header, and handling comma as thousands separator
df_pop = pd.read_csv(
    'L1_data/UK_census_population.csv',
    skiprows=5,        # Skip first 5 rows. Wnhy?
    thousands=',',     # Interpret commas as thousands separators
    header=0           # After skipping, the first row becomes the header
)

print(df_pop.head())
```

You might wonder why skipping the first 5 rows and setting *thousands=','*. I learnt this after opening this csv file in a text editor and lots of trial-and-errors. 

![]({{< var module.web >}}/sessions/L1_images/uk_pop_csv_screenshot.jpg){width="600"} 

<!-- ![](L1_images/uk_pop_csv_screenshot.jpg){width=600} -->

Then, we printed the first few rows of this dataset using *df_pop.head()*.

## Describing the dataframe

### Which columns are included?

```{python}
list(df_pop.columns)
```

It is a pain to deal with whitespaces in a column, so good practice is to replace the whitespaces (eg tabs, multiple spaces) within column names with *underscore*.

```{python}
df_pop.columns = df_pop.columns.str.replace(r'\s+', '_', regex=True)
print(list(df_pop.columns)) # check again
```

### How many rows & cols are included?

```{python}
rows, cols = df_pop.shape
print(f"Rows: {rows}, Columns: {cols}")
```

### Geography matters

This dataset contains multiple geographies of UK and different geographies are incomparable. We can check the *Area_type* column:

```{python}
print(df_pop.Area_type.value_counts())
```

So there are 355 records of *Local Authority*， 9 records of *Region*, 2 of *Country*, and 1 of 'National'. For an introduction to these terms, see [this article on ONS](https://www.ons.gov.uk/methodology/geography/ukgeographies/administrativegeography/england).

We will focus on the local authorities, so we apply a filter:

```{python}
df_pop_la = df_pop[df_pop['Area_type'] == 'Local Authority']
```

### Overview of the columns

There are two pandas functions that give overview of a dataframe. - `info()`: shows column data types, non‑null counts, and memory usage. - `describe()`: shows summary statistics for numeric data (count, mean, std, min, quartiles, max) - `describe(include='all')`: for both numeric data and non‑numeric data (count, unique, top value, frequency).

```{python}
print(df_pop_la.info())
print(df_pop_la.describe())
```

## Describing census 2021 population

Now, we focus on describing the local authority population from census 2021. The first question is, what data type is this variable - *nominal*, *ordinal*, *interval*, or *ratio*？

:::{.callout-note}
The data type of a variable is different from how it’s stored in memory. For example, the *Area_type* variable can be encoded for convenience as 0 (“national”), 1 (“country”), and 2 (“local authority”). Although these are stored as numbers, Area_type is not truly numeric data — it’s an *nominal* variable.
:::

Does it make sense to say 'The population of LA AAA is twice of LA BBB'? Yes. So, this variable is of *ratio* type.

### max and min

What is the maximum population size in census 2021?

```{Python}
print("Max population: ", df_pop_la['Population_2021'].max(skipna=True))
```

Which LAs have the maximum population size? *The code above is a bit complicated*.

```{python}
print("{} have the maximum population of {}".format(
    ", ".join(df_pop_la.loc[df_pop_la['Population_2021'] == df_pop_la['Population_2021'].max(skipna=True), 'Area_name']), 
    df_pop_la['Population_2021'].max(skipna=True))
    )
```

What it does: - Finds the max population while ignoring NaNs. - Selects all rows with that population. - Joins their Area_name values into a comma-separated string.

Two new Python functions here: - *format()*: Inserts variables into a string by replacing {} placeholders in order with provided arguments. - *join()*: Combines the elements of an iterable into one string using the given separator before .join().

Which LAs have the minimum population?

```{python}
print("{} have the minimum population of {}".format(
    ", ".join(df_pop_la.loc[df_pop_la['Population_2021'] == df_pop_la['Population_2021'].min(skipna=True), 'Area_name']), 
    df_pop_la['Population_2021'].min(skipna=True))
    )
```

### NA value and outliers?

Are there NA values or outliers in this variable? From results of `info()`, there are no NA values.

To detect outliers, we will implement the Tukey Fences method using pandas function, as pandas does not provide a built-in function for this method.

```{python}
# Calculate Q1, Q3, and IQR
Q1 = df_pop_la['Population_2021'].quantile(0.25)
Q3 = df_pop_la['Population_2021'].quantile(0.75)
IQR = Q3 - Q1

# Tukey's fences
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Detect outliers
outliers = df_pop_la[
    (df_pop_la['Population_2021'] < lower_bound) |
    (df_pop_la['Population_2021'] > upper_bound)
]

print("Lower bound:", lower_bound)
print("Upper bound:", upper_bound)
print("How many outliers?", outliers.shape[0])
print("Outliers:\n", outliers)
```

There are 33 outliers in this dataset. Think about the three types of outliers that we discussed. Which type do these 33 outliers beloong to?

- **Error Outlier**
- **Irregular Pattern Outlier**
- **Influential Outlier**

### Boxplot

To create a boxplot of this variable:

```{python}
import matplotlib.pyplot as plt

# Create boxplot
df_pop_la['Population_2021'].plot(kind='box', title='LA Population 2021 Boxplot')

plt.ylabel('Population')
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()
```

What do you observe from this boxplot? There are lots of values above the 

## Exploring Percentage_change

*Now*, we turn to explore the variable *Percentage_change*, which represents the relative change from the 2011 census to 2021 census.

Try completing the code below on your own. Practice makes perfect!

### Which LAs experienced the largest population percentage change? To what extent?

::: qna
#### Question

``` python
print("{} have the largest population percentage change of {}%".format(
    ", ".join(df_pop_la.loc[??['??'] == ??['??'].max(skipna=True), 'Area_name']), 
    df_pop_la['Population_2021'].??(skipna=True))
    )
```

#### Answer

```{python}
print("{} have the largest population percentage change of {}%".format(
    ", ".join(df_pop_la.loc[df_pop_la['Percentage_change'] == df_pop_la['Percentage_change'].max(skipna=True), 'Area_name']), 
    df_pop_la['Percentage_change'].max(skipna=True))
    )
```
:::

### Which LAs experienced the smallest population percentage change? To what extent?

::: qna
#### Question

``` python
print("{} have the smallest population percentage change of {}%".format(
    ", ".??(df_pop_la.loc[df_pop_la[??] == ??['Percentage_change'].??(skipna=True), 'Area_name']), 
    df_pop_la['Percentage_change'].??(skipna=True))
    )
```

#### Answer

```{python}
print("{} have the smallest population percentage change of {}%".format(
    ", ".join(df_pop_la.loc[df_pop_la['Percentage_change'] == df_pop_la['Percentage_change'].min(skipna=True), 'Area_name']), 
    df_pop_la['Percentage_change'].min(skipna=True))
    )
```
:::

### Make a boxplot of Percentage_change

::: qna
#### Question

``` python
import matplotlib.pyplot as plt

# Create boxplot
df_pop_la[??].plot(kind=??, title='LA Population Percentage Change Boxplot')

plt.??('Percentage change')
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()
```

#### Answer

```{python}
import matplotlib.pyplot as plt

# Create boxplot
df_pop_la['Percentage_change'].plot(kind='box', title='LA Population Percentage Change Boxplot')

plt.ylabel('Percentage change')
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()
```
:::

## You're Done!

Congratulations on completing the first QM practical session! If you are still working on it, take you time.

Don’t worry about understanding every detail of the Python code — what matters most is knowing which functions to use for a specific task, like checking minimum and maximum values or generating boxplots, and knowing how to debug when it goes wrong. Remember, practice makes perfect.

